<!DOCTYPE html>
<html>
<head>
  <script src="eeg32.js"></script>
  <script src="./utils/gpu-browser.min.js" charset="UTF-8"></script>
  <script src="./utils/gpuJSUtils.js"></script>
  <link rel="stylesheet" href="./utils/uPlot.min.css">
  <script src="./utils/uPlot.iife.min.js"></script>
  <script src="./utils/smoothie.min.js"></script>

</head>
<body>
<p id="p">
  FYI I only got this working for the FreeEEG32 in Ubuntu so far!!! <br>
  Enable the experimental web platform features flag in chrome://flags and restart chrome if you haven't. <br>
</p>
<hr>
<button id="connect">Connect to EEG</button>
<button id="analyze">Analyze Data</button>
<button id="stop">Stop Analyzing</button>
<button id="record">Save CSV (does nothing)</button> 
<input type="text" id="freqStart" placeholder="lower bound" value="0">
<input type="text" id="freqEnd" placeholder="upper bound" value="100">
<button id="bandPass">Set BandPass</button>
<button id="mode">Mode</button>
<br><input type="text" id="channelView" placeholder="0,1,2,3,4,5,6,7" value="0,1,2,3,4,5,6,7">
<button id="setChannelView">Set Channel View</button>
<input type="text" id="channelTags" placeholder="0:Fp1,1:Fp2,2:Fpz" value="0:Fp1,1:Fp2,2:Fpz">
<button id="setTags">Set Tags</button>

<h3 id="uplottitle">ADC 0 FFTs w/ Bandpass</h3>
<div id="adc0"></div>
<h3>CH0 Band Amplitudes. Color codes: Purple - Delta, Orange - Theta, Green - Alpha, Blue - Beta, Red - Gamma</h3>
<canvas id="bandAverages" style="width: 75%; height: 200px"></canvas>
<h3>ADC0 Alpha Amplitudes (8-12Hz)</h3>
<canvas id="alphaAverages" style="width: 75%; height: 200px"></canvas>
<div id="contour"></div>

<script>

    if(!navigator.serial){
        document.getElementById("p").innerHTML = "navigator.serial not found! Enable #enable-experimental-web-platform-features in chrome://flags (search 'experimental') then refresh";
    }

    try { var EEG = new eeg32(); }
    catch (error) { alert("eeg32.js err: ", error) }

    try {
      window.gpu = new gpuUtils();
    }
    catch (err) { alert("gpu.js utils error: ", err); }


    var nChannels = 32; //Number of channels to sample
    var sps = 512; //Samples per second
    var nSec = 1; //Number of seconds to sample FFTs
    var freqStart = 0; //Beginning of DFT frequencies
    var freqEnd = 100; //End of DFT frequencies (max = SPS * 0.5, half the nyquist sampling rate)

    var mode = "FFT"; //"TimeSeries"
    var nSecGraph = 10; //number of seconds to show on the graph

    var posMagsList = []; // amplitudes (y-axis)
    var bandPassWindow = gpu.bandPassWindow(freqStart,freqEnd,sps); // frequencies (x-axis)

    //Assign channels in order. Use null for unassigned channels and don't list anything past the last channel you are using
    var channelTags = [ //Connect differentials (- channels) to common reference on each ADC
      {ch: 0, tag: "Fp1"},  //Channel 0
      {ch: 1, tag: "Fp2"},  //Channel 1
      {ch: 2, tag: "Fpz"},  //Channel 2 etc.
      {ch: 3, tag: "F3"},
      {ch: 4, tag: "F4"},
      {ch: 5, tag: "F7"},
      {ch: 6, tag: "F8"},
      {ch: 7, tag: "Cz"},
    ]; 

    var atlas = EEG.makeAtlas10_20(); //Make MNI atlas for a 10_20 system

    

    document.getElementById("connect").onclick = () => {EEG.setupSerialAsync();}

    var anim = null;

    document.getElementById("analyze").onclick = () => {if(EEG.port !== null){anim = requestAnimationFrame(analyzeEEG());} else{alert("connect the EEG first!")}}

    document.getElementById("stop").onclick = () => { cancelAnimationFrame(anim) }

    document.getElementById("record").onclick = () => { alert("dummy"); }

    document.getElementById("bandPass").onclick = () => {
      var freq0 = parseFloat(document.getElementById("freqStart").value);
      var freq1 = parseFloaT(document.getElementById("freqEnd").value);
      if (freq0 > freq1) {
        freq0 = 0;
      }
      if(freq1 > sps*0.5){
        freq1 = sps*0.5;
      }
      freqStart = freq0;
      freqEnd = freq1;
      bandPassWindow = gpu.bandPassWindow(freq0,freq1,sps);

      getBandFreqs(); //Update bands accessed by the atlas for averaging
    }

    document.getElementById("mode").onclick = () => {
      if(mode === "FFT"){
        mode = "TimeSeries";
        document.getElementById("uplottitle").innerHTML = "ADC0 signals";
	      plot.axes[0].values = (u, vals, space) => vals.map(v => +(v*0.001).toFixed(1) + "s");
      }
      else {
        mode = "FFT";
        document.getElementById("uplottitle").innerHTML = "ADC 0 FFTs w/ Bandpass";
	      plot.axes[0].values = (u, vals, space) => vals.map(v => +v.toFixed(1) + "Hz");
      }
    }

    document.getElementById("setChannelView").onclick = () => {
      var val = document.getElementById("channelView").value;
      var arr = val.split(",");
      var newSeries = [{}];
      arr.forEach((item,i) => {
        var found = false;
        let getTags = channelTags.find((o, j) => {
        if((o.ch === parseInt(item)) || (o.tag === item)){
          //console.log(item);
          newSeries.push({
            label:"A"+o.ch + ", Tag: "+o.tag,
            value: (u, v) => v == null ? "-" : v.toFixed(1),
            stroke: "rgb("+Math.random()*255+","+Math.random()*255+","+Math.random()*255+")"
          });
          found = true;
          return true;
          }
        });
        if (found === false){ //add tag
          if(parseInt(item) !== NaN){
            channelTags.push({ch:parseInt(item), tag: null});
            newSeries.push({
              label:"A"+parseInt(item) + ", Tag: null",
              value: (u, v) => v == null ? "-" : v.toFixed(1),
              stroke: "rgb("+Math.random()*255+","+Math.random()*255+","+Math.random()*255+")"
            });
          }
          else {
            alert("Tag not assigned to channel: ", item);
          }
        }
      });

      plot.destroy();
      makeuPlot(newSeries);
    }
    
    document.getElementById("setTags").onclick = () => {
      var val = document.getElementById("channelTags").value;
      //console.log(val);
      var arr = val.split(",");
      //console.log(arr);
      arr.forEach((item,i) => {
        var dict = item.split(":");
        var found = false;
        let setTags = channelTags.find((o, i) => {
          if(o.ch === parseInt(dict[0])){
            //console.log(o);
            channelTags[i].tag = dict[1];
            found = true;
            return true;
            }
          else if(o.tag === dict[1]){
            channelTags[i].tag = null; //Set tag to null since it's begin assigned to another channel
          }
        });
        if (found === false){
          var ch = parseInt(dict[0]);
          if((ch > 0) && (ch < nChannels)){
            channelTags.push({ch:parseInt(ch), tag: dict[1]});
          }
        }
      });

      val = document.getElementById("channelView").value;
      arr = val.split(",");
      var newSeries = [{}];
      arr.forEach((item,i) => {
        var found = false;
        let getTags = channelTags.find((o, j) => {
        if((o.ch === parseInt(item)) || (o.tag === item)){
          //console.log(item);
          newSeries.push({
            label:"A"+o.ch + ", Tag: "+o.tag,
            value: (u, v) => v == null ? "-" : v.toFixed(1),
            stroke: "rgb("+Math.random()*255+","+Math.random()*255+","+Math.random()*255+")"
          });
          found = true;
          return true;
          }
        });
        if (found === false){ //add tag
          if(parseInt(item) !== NaN){
            channelTags.push({ch:parseInt(item), tag: null});
            newSeries.push({
              label:"A"+parseInt(item) + ", Tag: null",
              value: (u, v) => v == null ? "-" : v.toFixed(1),
              stroke: "rgb("+Math.random()*255+","+Math.random()*255+","+Math.random()*255+")"
            });
          }
          else {
            alert("Tag not assigned to channel: ", item);
          }
        }
      });

      plot.destroy();
      makeuPlot(newSeries);
    }



    var deltaFreqs = [[],[]], thetaFreqs = [[],[]], alphaFreqs = [[],[]], betaFreqs = [[],[]], gammaFreqs = [[],[]]; //x axis values and indices for named EEG frequency bands
    var getBandFreqs = () => {
      bandPassWindow.forEach((item,idx) => {
        if((item >= 0.5) && (item <= 4)){
          deltaFreqs[0].push(item); deltaFreqs[1].push(idx);
        }
        if((item > 4) && (item <= 8)) {
          thetaFreqs[0].push(item); thetaFreqs[1].push(idx);
        }
        if((item > 8) && (item <= 12)){
          alphaFreqs[0].push(item); alphaFreqs[1].push(idx);
        }
        if((item > 12) && (item <= 35)){
          betaFreqs[0].push(item); betaFreqs[1].push(idx);
        }
        if(item > 35) {
          gammaFreqs[0].push(item); gammaFreqs[1].push(idx);
        }
      });
    }

    getBandFreqs()

    var plot = null;

    //Make uPlot (will need to generalize this stuff for a nicer API to customize plots)
    var makeuPlot = (series=undefined) => {
      var newSeries = [{}];
      if(series === undefined) {
        channelTags.forEach((row,i) => {
          newSeries.push({
            label:"A"+row.ch + ", Tag: "+row.tag,
            value: (u, v) => v == null ? "-" : v.toFixed(1),
            stroke: "rgb("+Math.random()*255+","+Math.random()*255+","+Math.random()*255+")"
          });
        });
      }
      else {
        newSeries = series;
      }
      
      var uPlotOptions = {
        title: "ADC0",
        width: 1000,
        height: 300,
        series: newSeries,
        axes: [
          {
          scale: "Hz",
          values: (u, vals, space) => vals.map(v => +v.toFixed(1) + "Hz")
          },
        ]
      }

      var uPlotData = [ //Dummy data
        bandPassWindow
      ];

      channelTags.forEach((tag,i) => {
        uPlotData.push(bandPassWindow);
      })

      plot = new uPlot(uPlotOptions, uPlotData, document.getElementById("adc0") );

    }

    makeuPlot();
    
    //Make smoothiejs charts
    var deltaSeries = new TimeSeries(),
        thetaSeries = new TimeSeries(),
        alphaSeries = new TimeSeries(),
        betaSeries = new TimeSeries(),
        gammaSeries = new TimeSeries();        

    var bandchart = new SmoothieChart({ responsive: true,
      grid: { strokeStyle:'rgb(125, 0, 0)', fillStyle:'rgb(10, 10, 10)',
      lineWidth: 1, millisPerLine: 250, verticalSections: 6, },
      labels: { fillStyle:'rgb(60, 0, 0)' }
    });
    
    bandchart.addTimeSeries(deltaSeries, { strokeStyle: 'purple', fillStyle: 'rgba(128,0,128,0.2)', lineWidth: 2 });
    bandchart.addTimeSeries(thetaSeries, { strokeStyle: 'orange', fillStyle: 'rgba(255,128,0,0.2)', lineWidth: 2 });
    bandchart.addTimeSeries(alphaSeries, { strokeStyle: 'green', fillStyle: 'rgba(0,255,0,0.2)', lineWidth: 2 });
    bandchart.addTimeSeries(betaSeries,  { strokeStyle: 'blue', fillStyle: 'rgba(0,0,255,0.2)', lineWidth: 2 });
    bandchart.addTimeSeries(gammaSeries, { strokeStyle: 'red', fillStyle: 'rgba(255,0,0,0.2)', lineWidth: 2 });
    bandchart.streamTo(document.getElementById("bandAverages"), 500);


    var alphaSeries1 = new TimeSeries(),
        alphaSeries2 = new TimeSeries(),
        alphaSeries3 = new TimeSeries(),
        alphaSeries4 = new TimeSeries(),
        alphaSeries5 = new TimeSeries(),
        alphaSeries6 = new TimeSeries(),
        alphaSeries7 = new TimeSeries();

    var alphachart = new SmoothieChart({ responsive: true,
      grid: { strokeStyle:'rgb(0, 0, 125)', fillStyle:'rgb(10, 10, 10)',
      lineWidth: 1, millisPerLine: 250, verticalSections: 6, },
      labels: { fillStyle:'rgb(60, 0, 0)' }
    });
    
    alphachart.addTimeSeries(alphaSeries, { strokeStyle: 'rgba(0, 0, 255, 1)', fillStyle: 'rgba(255, 0, 200, 0.2)', lineWidth: 2 });
    alphachart.addTimeSeries(alphaSeries1, { strokeStyle: 'rgba(255, 155, 0, 1)', fillStyle: 'rgba(255, 155, 0, 0.2)', lineWidth: 2 });
    alphachart.addTimeSeries(alphaSeries2, { strokeStyle: 'rgba(255, 0, 200, 1)', fillStyle: 'rgba(0, 0, 255, 0.2)', lineWidth: 2 });
    alphachart.addTimeSeries(alphaSeries3,  { strokeStyle: 'rgba(0, 255, 0, 1)', fillStyle: 'rgba(0, 255, 0, 0.2)', lineWidth: 2 });
    alphachart.addTimeSeries(alphaSeries4, { strokeStyle: 'rgba(0, 255, 255, 1)', fillStyle: 'rgba(0, 255, 255, 0.2)', lineWidth: 2 });
    alphachart.addTimeSeries(alphaSeries5, { strokeStyle: 'rgba(100, 0, 255, 1)', fillStyle: 'rgba(100, 0, 255, 0.2)', lineWidth: 2 });
    alphachart.addTimeSeries(alphaSeries6,  { strokeStyle: 'rgba(255, 255, 100, 1)', fillStyle: 'rgba(255, 255, 100, 0.2)', lineWidth: 2 });
    alphachart.addTimeSeries(alphaSeries7, { strokeStyle: 'rgba(200, 100, 55, 1)', fillStyle: 'rgba(200, 100, 55, 0.2)', lineWidth: 2 });
    alphachart.streamTo(document.getElementById("alphaAverages"), 500);


    function mean(arr){
      var sum = arr.reduce((prev,curr)=> curr += prev);
      return sum / arr.length;
    }

    function getAtlasCoordsList(fromAtlas) {
      var coords = {x: [], y: [], z: []};
      for(var i = 0; i< fromAtlas.length; i++) {
        coords.x.push(fromAtlas[i].data.x);
        coords.y.push(fromAtlas[i].data.y);
        coords.z.push(fromAtlas[i].data.z);
      }

      return coords;
    }

    var coords = getAtlasCoordsList(atlas);



    //Looping animation to analyze channel data and update plots
    var analyzeEEG = () => {
      var buffer = [];

      //for(var i = 0; i < nChannels; i++){
      //  var channel = "A"+i
      //  buffer.push(EEG.data[channel].slice(EEG.data.counter - sps, EEG.data.counter)); //Lets get 1 second of the latest data
      //}
      
      //console.time("GPU DFTx32");
      //posMagsList = gpu.MultiChannelDFT_BandPass(buffer, nSec, freqStart, freqEnd);
      //console.timeEnd("GPU DFTx32");
      
      //Select only chosen channels
      for(var i = 0; i < channelTags.length; i++){
        if(i < nChannels){
          var channel = "A"+channelTags[i].ch;
          buffer.push(EEG.data[channel].slice(EEG.data.counter - sps, EEG.data.counter));
        }
      }

      console.time("GPU DFTx8");
      posMagsList = gpu.MultiChannelDFT_BandPass(buffer, nSec, freqStart, freqEnd);
      console.timeEnd("GPU DFTx8");

      //Separate and report channel results by band
      channelTags.forEach((row,i) => {
          if((row.tag !== null) && (i < nChannels)){
            //console.log(tag);
            channelBands(i,row.tag);
          }
          if(tag === null){
            posMagsList.splice(i,0,null); //Add nulls to the magnitudes lists for the channelBands function to work
          }
        });
      

      if(mode === "FFT"){

        //Animate plot(s)
        uPlotData = [
          bandPassWindow
        ];

        channelTags.forEach((row,i) => {
          uPlotData.push(posMagsList[row.ch]);
        });
        
      }

      else if (mode === "TimeSeries") {
        var nsamples = Math.floor(sps*nSecGraph);

        uPlotData = [
          EEG.data.ms.slice(EEG.data.counter - nsamples, EEG.data.counter)
        ];

        channelTags.forEach((row,i) => {
          uPlotData.push(EEG.data["A"+row.ch].slice(EEG.data.counter - nsamples, EEG.data.counter));
        });
      }

      //Update visuals
      //Get Coord
      var coord = EEG.getAtlasCoordByTag(channelTags[0].tag);


      plot.setData(uPlotData);

      
      var now = Date.now();
      deltaSeries.append(now, coord.data.means.delta[coord.data.means.delta.length-1]);
      thetaSeries.append(now, coord.data.means.theta[coord.data.means.theta.length-1]);
      alphaSeries.append(now, coord.data.means.alpha[coord.data.means.alpha.length-1]);
      betaSeries.append(now, coord.data.means.beta[coord.data.means.beta.length-1]);
      gammaSeries.append(now, coord.data.means.gamma[coord.data.means.gamma.length-1]);

      //Alpha averages for ADC 0
      alphaSeries1.append(now, atlas[1].data.means.alpha[atlas[1].data.means.alpha.length-1]);
      alphaSeries2.append(now, atlas[2].data.means.alpha[atlas[2].data.means.alpha.length-1]);
      alphaSeries3.append(now, atlas[3].data.means.alpha[atlas[3].data.means.alpha.length-1]);
      alphaSeries4.append(now, atlas[4].data.means.alpha[atlas[4].data.means.alpha.length-1]);
      alphaSeries5.append(now, atlas[5].data.means.alpha[atlas[5].data.means.alpha.length-1]);
      alphaSeries6.append(now, atlas[6].data.means.alpha[atlas[6].data.means.alpha.length-1]);
      alphaSeries7.append(now, atlas[7].data.means.alpha[atlas[7].data.means.alpha.length-1]);
      

      setTimeout(()=>{anim = requestAnimationFrame(analyzeEEG);},100); //Hard fps limit
    }


    //This should be better optimized for animating e.g. integrated into a shader
    var channelBands = (channel,tag) => {
	  //console.time("slicing bands");
      let atlasCoord = atlas.find((o, i) => {
        if(o.tag === tag){
	        atlas[i].data.times.push(performance.now());
          atlas[i].data.amplitudes.push(posMagsList[channel]);
          var delta = posMagsList[channel].slice( deltaFreqs[0][1], deltaFreqs[1][deltaFreqs[1].length-1]);
	        atlas[i].data.slices.delta.push(delta);
          atlas[i].data.means.delta.push(mean(delta));
          var theta = posMagsList[channel].slice( thetaFreqs[0][1], thetaFreqs[1][thetaFreqs[1].length-1]);
	        atlas[i].data.slices.theta.push(theta);
          atlas[i].data.means.theta.push(mean(theta));
          var alpha = posMagsList[channel].slice( alphaFreqs[0][1], alphaFreqs[1][alphaFreqs[1].length-1]);
	        atlas[i].data.slices.alpha.push(alpha);
          atlas[i].data.means.alpha.push(mean(alpha));
          var beta  = posMagsList[channel].slice( betaFreqs[0][1],  betaFreqs[1][betaFreqs[1].length-1]);
	        atlas[i].data.slices.beta.push(beta);
          atlas[i].data.means.beta.push(mean(beta));
          var gamma = posMagsList[channel].slice( gammaFreqs[0][1], gammaFreqs[1][gammaFreqs[1].length-1]);
	        atlas[i].data.slices.gamma.push(gamma);
          atlas[i].data.means.gamma.push(mean(gamma));
	  //console.timeEnd("slicing bands");
          return true;
        }
      });
      
    }

    //Next do a 10-20 or 32 ch contour plot with a way to set the channels


  //E.g. for gamma only do 'var gamma = posMagsList[0].slice(gamma[0][1],gamma[alpha.length][1]);'
  //To average a particular band, do 'var gammaMean = mean(gamma);'

</script>
</body>
</html>
