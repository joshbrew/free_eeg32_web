<!DOCTYPE html>
<html>
<head>
  <script src="eeg32.js"></script>
  <script src="./other/gpu-browser.min.js" charset="UTF-8"></script>
  <script src="./other/gpuJSUtils.js"></script>
  
  <script src="./other/d3.v5.min.js"></script>
  <script src="./other/plotly-latest.min.js"></script>
</head>
<body>
<p id="p">
  FYI I only got this working for the FreeEEG32 in Ubuntu so far!!! <br>
  Enable the experimental web platform features flag in chrome://flags and restart chrome if you haven't. <br>
  Open the console, type EEG.setupSerialAsync() to connect to the data stream with the EEG plugged in. <br>
  Check EEG.data for decoded data <br>
  If EEG.decode() returns true it decoded a line successfully into EEG.data :-)
</p>
<hr>
<h3>Change 'channelToPlot' in console to visualize different channel results while running</h3>
<div id="line"></div>
<div id="contour"></div>

<script>


  if(!navigator.serial){
      document.getElementById("p").innerHTML = "navigator.serial not found! Enable #enable-experimental-web-platform-features in chrome://flags (search 'experimental') then refresh";
  }

  try { var EEG = new eeg32(); }
  catch (error) { alert("eeg32.js err: ", error) }

  try {
    window.gpu = new gpuUtils();
  }
  catch (err) { alert("gpu.js utils error: ", err); }

    var nChannels = 32; //Number of channels to sample
    var sps = 512; //Samples per second
    var nSec = 1; //Number of seconds to sample
    var freqStart = 0; //Beginning of DFT frequencies
    var freqEnd = 100; //End of DFT frequencies (max = SPS * 0.5, half the nyquist sampling rate)

    var posMagsList = []; // amplitudes (y-axis)
    var bandPassWindow = gpu.bandPassWindow(freqStart,freqEnd,sps); // frequencies (x-axis)


    var deltaFreqs = [], thetaFreqs = [], alphaFreqs = [], betaFreqs = [], gammaFreqs = []; //x axis values and indices for named EEG frequency bands
    bandPassWindow.forEach((item,idx) => {
      if((item >= 0.5) && (item <= 4)){
        deltaFreqs.push([item,idx]);
      }
      if((item > 4) && (item <= 8)) {
        thetaFreqs.push([item,idx]);
      }
      if((item > 8) && (item <= 12)){
        alphaFreqs.push([item,idx]);
      }
      if((item > 12) && (item <= 35)){
        betaFreqs.push([item, idx]);
      }
      if(item > 35) {
        gammaFreqs.push([item, idx]);
      }
    });
    
    //Assign channels in order. Use null for unassigned channels and don't list anything past the last channel you are using
    var channelTags = [ //This is probably not correct for differential channels, still learning here
      "Fp1", //Channel 0
      null,  //Channel 1
      "Fp2"  //Channel 2
    ]; 

    var channelToPlot = 0;
    
    var atlas = EEG.makeAtlas10_20(); //Make MNI atlas for a 10_20 system

    function mean(arr){
      var sum = arr.reduce((prev,curr)=> curr += prev);
      return sum / arr.length;
    }

    function getAtlasCoordsList(fromAtlas) {
      var coords = {x: [], y: [], z: []};
      for(var i = 0; i< fromAtlas.length; i++) {
        coords.x.push(fromAtlas[i].data.x);
        coords.y.push(fromAtlas[i].data.y);
        coords.z.push(fromAtlas[i].data.z);
      }

      return coords;
    }

    var coords = getAtlasCoordsList(atlas);

    Plotly.newPlot('line', [{
        x: bandPassWindow,
        y: bandPassWindow //change to e.g. posMagsList[0]
      }]);

    Plotly.newPlot('contour', [{
      x: coords.x,
      y: coords.y,
      z: coords.z,
      type: 'scatter3d'
      }]);



    //Looping animation to analyze channel data and update plots
    var analyzeEEG = () => {
      var buffer = [];
      //var ct = EEG.data.counter;
      for(var i = 0; i < nChannels; i++){
        var channel = "A"+i
        buffer.push(EEG.data[channel].slice(EEG.data.counter - sps, EEG.data.counter)); //Lets get 1 second of the latest data
      }
      posMagsList = gpu.MultiChannelDFT_BandPass(buffer, 1, freqStart, freqEnd);

      //Separate and report channel results by band
      channelTags.forEach((tag,i) => {
        if((tag !== null) && (i < nChannels)){
          channelBands(i,tag);
        }
      })

      //Update visuals

      //Animate plot(s)
      Plotly.animate('line', 
        {
          data: [{y: posMagsList[channelToPlot]}],
          traces: [0],
          layout: {}
        }, 
        {
          transition: {
            duration: 20,
            easing: 'cubic-in-out'
          }, 
          frame: {
            duration: 20
          }
        });

      //Plotly.animate('contour',{});

      setTimeout(()=>{requestAnimationFrame(analyzeEEG);},100); //Hard fps limit
    }


    //This should be better optimized for animating e.g. integrated into a shader
    var channelBands = (channel,tag) => {
      let atlasCoord = atlas.find((o, i) => {
        if(o.tag === tag){
          atlas[i].data.amplitudes = posMagsList[channel];
          var delta = posMagsList[channel].slice(deltaFreqs[0][1],deltaFreqs.length);
          atlas[i].data.means.delta =  mean(delta);
          var theta = posMagsList[channel].slice(thetaFreqs[0][1],thetaFreqs.length);
          atlas[i].data.means.theta = mean(theta);
          var alpha = posMagsList[channel].slice(alphaFreqs[0][1],alphaFreqs.length);
          atlas[i].data.means.alpha = mean(alpha);
          var beta  = posMagsList[channel].slice( betaFreqs[0][1],  betaFreqs.length);
          atlas[i].data.means.beta  = mean(beta);
          var gamma = posMagsList[channel].slice( gammaFreqs[0][1], gammaFreqs.length)
          atlas[i].data.means.gamma = mean(gamma)
          return true;
        }
      });
      
    }


  

    //Next do a 10-20 or 32 ch contour plot with a way to set the channels


  //E.g. for gamma only do 'var gamma = posMagsList[0].slice(gamma[0][1],gamma[alpha.length][1]);'
  //To average a particular band, do 'var gammaMean = mean(gamma);'

</script>
</body>
</html>
